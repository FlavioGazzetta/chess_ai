==============================
File: main.py
Path: /home/fg723/personal_projects/chess_ai/main.py
------------------------------
# main.py

import queue
import threading
import logging

from viewer import view_moves
from trainer import train_ai

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("main")

def main():
    logger.info("Creating shared queue")
    q = queue.Queue()

    logger.info("Launching viewer thread")
    t = threading.Thread(target=view_moves, args=(q,), daemon=True)
    t.start()

    logger.info("Launching training")
    train_ai(q)
    logger.info("Training finished")

if __name__ == "__main__":
    main()

==============================
File: chess_env.py
Path: /home/fg723/personal_projects/chess_ai/chess_env.py
------------------------------
# chess_env.py
# ----------------------------------------------------------
import random
import chess
import numpy as np
import gymnasium as gym
from gymnasium import spaces

import json

QUEUE = None  # will be injected by trainer.py


class ChessEnvSingle(gym.Env):
    """Discrete-action single-agent chess environment with padded planes."""

    def __init__(self):
        super().__init__()

        # Action space: 4672 = 64 from-squares × 73 to-square/under-promo options
        self.action_space = spaces.Discrete(4672)

        # Observation: 8×8×111 bool planes → float32 padded to 12×12 so RLlib is happy
        self.observation_space = spaces.Box(0.0, 1.0, (10, 10, 111), dtype=np.float32)

        self.board = chess.Board()

    # ------------------------------------------------------------------ helpers
    @staticmethod
    def _action_to_uci(action: int) -> str:
        """Very simple, slightly hacky mapping → UCI string."""
        from_sq = action // 73
        to_idx  = action % 73
        to_sq   = (to_idx % 64)
        promo   = ["", "q", "r", "b", "n"][to_idx // 64]  # 0-3 promotion pieces + ''
        return chess.square_name(from_sq) + chess.square_name(to_sq) + promo

    def _legal_random(self) -> chess.Move:
        """Choose a random legal move (board already checked to have moves)."""
        return random.choice(list(self.board.legal_moves))

    # ----------------------------------------------------------------- Gym API
    def reset(self, *, seed=None, options=None):
        super().reset(seed=seed)
        self.board.reset()
        return self._obs(), {}

    def step(self, action):
        # -------- Agent move --------------------------------------------------
        desired_uci = self._action_to_uci(int(action))
        try:
            move = chess.Move.from_uci(desired_uci)
            if move not in self.board.legal_moves:
                raise ValueError("illegal")  # force except path below
        except Exception:  # malformed or illegal
            move = self._legal_random()

        self.board.push(move)

        # -------- Optional “viewer” stream ------------------------------------
        if QUEUE is not None:
            QUEUE.put(json.dumps({
                "game": 0,                       # or self.game_id if you have one
                "fen": self.board.fen(),         # current board position
                "move": desired_uci,             # move just played
                "result": None                   # fill when game is over
            }))

        # -------- Opponent (very weak) ----------------------------------------
        if not self.board.is_game_over():
            self.board.push(self._legal_random())

        # -------- Compute reward & done flags ---------------------------------
        terminated = self.board.is_game_over()
        truncated  = False  # -- no max-turn cap yet

        # win=+1, loss=-1, draw=0
        result_reward = {
            "1-0": 1.0,
            "0-1": -1.0,
            "1/2-1/2": 0.0
        }
        reward = result_reward.get(self.board.result(), 0.0)

        return self._obs(), reward, terminated, truncated, {}

    # ----------------------------------------------------------------- internal
    def _obs(self):
        """Return 12×12×111 float32 planes (zero-padded from 8×8)."""
        planes = np.zeros((10, 10, 111), dtype=np.float32)
        # 👉 quick and dirty: just place 8×8 slice into the middle
        raw = self._raw_planes()  # 8×8×111 bool
        planes[2:10, 2:10, :] = raw
        return planes

    @staticmethod
    def _raw_planes():
        # minimal placeholder — implement your own board-to-planes function
        return np.zeros((8, 8, 111), dtype=np.float32)

==============================
File: trainer.py
Path: /home/fg723/personal_projects/chess_ai/trainer.py
------------------------------
# trainer.py  (use this to replace your current trainer.py)

import queue
import logging

import ray
from ray.tune.registry import register_env
from ray.rllib.algorithms.ppo import PPO

import chess_env  # our padded, float32 observation env

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("trainer")


def train_ai(shared_queue: queue.Queue[str]):
    # 1) Inject shared queue for live streaming
    chess_env.QUEUE = shared_queue
    logger.info("Injected QUEUE into env module")

    # 2) Start (or re-use) local Ray
    ray.init(ignore_reinit_error=True, log_to_driver=True)

    # 3) Register single-agent chess environment
    register_env("chess_single", lambda cfg: chess_env.ChessEnvSingle())
    logger.info("Registered env 'chess_single'")

    # 4) Build PPO configuration (legacy stack, so no warnings)
    config = {
        "env": "chess_single",
        "framework": "torch",
        "num_gpus": 1,               # use your RTX 4070
        "num_workers": 0,            # single-process rollouts
        "model": {                   # legacy ModelV2 API
            "conv_filters": [
                [32, [8, 8], 4],
                [64, [4, 4], 2],
                [64, [3, 3], 1],
            ],
            "fcnet_hiddens": [128, 128],
        },
        "train_batch_size": 2000,
        "sgd_minibatch_size": 256,
        "num_sgd_iter": 10,
        "gamma": 0.99,
    }

    # ---- ONE extra line to silence the new-stack warnings ----
    config["api_stack"] = {
        "enable_rl_module_and_learner": False,
        "enable_env_runner_and_connector_v2": False,
    }
    # ----------------------------------------------------------

    # 5) Build PPO algorithm
    algo = PPO(config=config)
    logger.info("Built PPO algorithm")

    # 6) Simple training loop
    for i in range(1, 100000):
        result = algo.train()
        if i % 10 == 0:
            logger.info(
                f"Iter {i:>3}  avg_reward={result['episode_reward_mean']:.3f}  "
                f"timesteps_total={result['timesteps_total']}"
            )

    algo.stop()
    logger.info("Training complete")


if __name__ == "__main__":
    q = queue.Queue()
    train_ai(q)

==============================
File: viewer.py
Path: /home/fg723/personal_projects/chess_ai/viewer.py
------------------------------
# viewer.py ─ show every move, one board, no flicker
from __future__ import annotations
import json, queue, sys, time, pygame, chess, threading
from colorama import Fore, Style, init as _cinit
_cinit(autoreset=True)

# ───── constants ──────────────────────────────────────────────────────────
SQ = 72; BOARD_PX = 8*SQ
LIGHT, DARK = (240,217,181), (181,136, 99)
FRAME = (70,70,70); FPS = 60
UNICODE = {"P":"♙","N":"♘","B":"♗","R":"♖","Q":"♕","K":"♔",
           "p":"♟","n":"♞","b":"♝","r":"♜","q":"♛","k":"♚"}
QUEUE: "queue.Queue[str]|None" = None

# ───── helpers ────────────────────────────────────────────────────────────
_font_cache:dict[int,pygame.font.Font]={}
def _font(sz:int)->pygame.font.Font:
    if sz not in _font_cache:
        _font_cache[sz] = pygame.font.SysFont("DejaVuSans", sz, bold=True)
    return _font_cache[sz]

def _background()->pygame.Surface:
    surf=pygame.Surface((BOARD_PX,BOARD_PX))
    surf.fill(FRAME)
    for r in range(8):
        for c in range(8):
            col = LIGHT if (r+c)&1 else DARK
            pygame.draw.rect(surf,col,(c*SQ,r*SQ,SQ,SQ))
    return surf

def _piece_imgs()->dict[str,pygame.Surface]:
    imgs={}
    for sym,uni in UNICODE.items():
        col=(255,255,255) if sym.isupper() else (25,25,25)
        txt=_font(int(SQ*0.8)).render(uni,True,col)
        s=pygame.Surface((SQ,SQ),pygame.SRCALPHA); s.blit(txt,txt.get_rect(center=(SQ//2,SQ//2)))
        imgs[sym]=s
    return imgs

# ───── viewer main loop ───────────────────────────────────────────────────
def view_moves(shared:queue.Queue[str])->None:
    global QUEUE; QUEUE=shared
    pygame.init(); win=pygame.display.set_mode((BOARD_PX,BOARD_PX))
    pygame.display.set_caption("Chess Viewer"); clock=pygame.time.Clock()

    back   = _background();  piece_img=_piece_imgs()
    board  : chess.Board|None=None
    last   : dict[int,chess.Piece]={}

    running=True
    while running:
        # pull **one** message (blocking ≤1/FPS s) so we repaint each ply
        try: raw=QUEUE.get(timeout=1/FPS)
        except queue.Empty: raw=None

        if raw:
            try: fen=json.loads(raw)["fen"]
            except Exception as e:
                print(Fore.RED+f"[viewer] bad msg: {e}"+Style.RESET_ALL); continue

            # start/replace board when new game or first FEN
            if board is None or board.is_game_over():
                board=chess.Board(fen); last={}
                back=_background()      # fresh clean board
            else:
                board.set_fen(fen)

            new_map=board.piece_map()
            changed={sq for sq in set(last)|set(new_map) if last.get(sq)!=new_map.get(sq)}
            last=new_map

            for sq in changed:
                r,c=divmod(sq,8)
                col = LIGHT if (r+c)&1 else DARK
                pygame.draw.rect(back,col,(c*SQ,r*SQ,SQ,SQ))
                if piece:=new_map.get(sq):
                    back.blit(piece_img[piece.symbol()],(c*SQ,r*SQ))

            win.blit(back,(0,0))
            pygame.display.flip()         # immediate render after this move

        # handle quit
        for ev in pygame.event.get():
            if ev.type==pygame.QUIT: running=False
        clock.tick(FPS)

    pygame.quit(); sys.exit()

# standalone quick-test
if __name__=="__main__":
    import multiprocessing as mp, random
    q=mp.Manager().Queue()
    threading.Thread(target=view_moves,args=(q,),daemon=True).start()
    b=chess.Board(); q.put(json.dumps({"fen":b.fen()}))
    while not b.is_game_over():
        b.push(random.choice(list(b.legal_moves)))
        q.put(json.dumps({"fen":b.fen()})); time.sleep(0.3)

